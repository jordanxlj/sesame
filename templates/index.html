<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>SuperTrend Chart</title>
    <script src="/static/lightweight-charts.standalone.production.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <style>
        #chart { width: 1000px; height: 400px; }
        #volume-chart { width: 1000px; height: 200px; margin-top: 8px; }
        body { font-family: Arial, sans-serif; }
        .form-bar { margin-bottom: 16px; }
        label { margin-right: 8px; }
    </style>
</head>
<body>
    <div class="form-bar">
        <label for="code">ËÇ°Á•®‰ª£Á†Å:</label>
        <select id="code" multiple="multiple" style="width:300px"></select>
        <label>ÊåáÊ†á:</label>
        <label><input type="checkbox" class="indicator" value="supertrend" checked>SuperTrend</label>
        <label><input type="checkbox" class="indicator" value="ma5">MA5</label>
        <label><input type="checkbox" class="indicator" value="ma10">MA10</label>
        <label><input type="checkbox" class="indicator" value="squeeze_momentum">Squeeze Momentum</label>
        <button onclick="loadChart()">Êü•ËØ¢</button>
        <button onclick="forceSyncCharts()" style="margin-left: 10px;">Âº∫Âà∂ÂêåÊ≠•</button>
    </div>
    <div id="info-bar" style="font-size:16px; margin-bottom:8px;"></div>
    <div id="chart"></div>
    <div id="volume-chart"></div>
    <script>
        // ===== ÂõæË°®Âü∫Á±ª =====
        class BaseChart {
            constructor(container, options = {}) {
                this.container = container;
                this.chart = null;
                this.series = [];
                this.options = {
                    width: 1000,
                    height: 400,
                    rightPriceScale: { visible: true },
                    leftPriceScale: { visible: false },
                    timeScale: { visible: true },
                    layout: {
                        backgroundColor: 'transparent',
                        textColor: '#333'
                    },
                    grid: {
                        vertLines: { color: '#e1e1e1' },
                        horzLines: { color: '#e1e1e1' }
                    },
                    ...options
                };
            }
            
            create() {
                if (this.chart) {
                    this.destroy();
                }
                this.chart = LightweightCharts.createChart(this.container, this.options);
                console.log(`${this.constructor.name} ÂàõÂª∫ÊàêÂäü`);
                this.onCreated();
                return this.chart;
            }
            
            destroy() {
                if (this.chart) {
                    this.series.forEach(series => {
                        try { this.chart.removeSeries(series); } catch (e) {}
                    });
                    this.series = [];
                    this.chart.remove();
                    this.chart = null;
                }
            }
            
            addSeries(type, options = {}) {
                if (!this.chart) return null;
                
                let series;
                switch (type) {
                    case 'candlestick':
                        series = this.chart.addCandlestickSeries(options);
                        break;
                    case 'line':
                        series = this.chart.addLineSeries(options);
                        break;
                    case 'histogram':
                        series = this.chart.addHistogramSeries(options);
                        break;
                    default:
                        return null;
                }
                
                this.series.push(series);
                return series;
            }
            
            setTimeRange(timeRange) {
                if (this.chart && timeRange) {
                    this.chart.timeScale().setVisibleRange(timeRange);
                }
            }
            
            getTimeRange() {
                return this.chart ? this.chart.timeScale().getVisibleRange() : null;
            }
            
            subscribeTimeRangeChange(handler) {
                if (this.chart) {
                    this.chart.timeScale().subscribeVisibleTimeRangeChange(handler);
                }
            }
            
            subscribeCrosshairMove(handler) {
                if (this.chart) {
                    this.chart.subscribeCrosshairMove(handler);
                }
            }
            
            onCreated() {}
        }
        
        // ===== ‰∏ªÂõæÁ±ª =====
        class MainChart extends BaseChart {
            constructor(container) {
                super(container, {
                    height: 600,
                    timeScale: {
                        visible: true,
                        timeVisible: true,
                        secondsVisible: false,
                        borderVisible: true,
                        rightOffset: 12,
                        barSpacing: 3,
                        fixLeftEdge: false,
                        fixRightEdge: false,
                        lockVisibleTimeRangeOnResize: true
                    }
                });
                this.volumeSeries = null;
                this.candleSeries = [];
                this.indicatorSeries = [];
                this.currentOhlcData = null;
                this.subCharts = [];
            }
            
            onCreated() {
                // ÂàõÂª∫Êàê‰∫§ÈáèÁ≥ªÂàó
                this.volumeSeries = this.addSeries('histogram', {
                    priceScaleId: 'volume',
                    priceFormat: { type: 'volume' },
                    scaleMargins: { top: 0.8, bottom: 0 },
                    color: '#26a69a'
                });
                
                // ÈÖçÁΩÆÊàê‰∫§Èáè‰ª∑Ê†ºËΩ¥
                this.chart.priceScale('volume').applyOptions({
                    scaleMargins: { top: 0.8, bottom: 0 },
                    alignLabels: true,
                    borderVisible: true
                });
                
                // ÁõëÂê¨Êó∂Èó¥ËΩ¥ÂèòÂåñ
                this.subscribeTimeRangeChange((timeRange) => {
                    if (!window.isUpdatingFromGlobal && timeRange) {
                        detectAndSyncZoom(timeRange, 'main');
                    }
                });
                
                // ÁõëÂê¨ÂçÅÂ≠óÁ∫øÁßªÂä®
                this.subscribeCrosshairMove((param) => {
                    this.handleCrosshairMove(param);
                });
            }
            
            addSubChart(subChart) {
                this.subCharts.push(subChart);
                console.log(`Ê∑ªÂä†Â≠êÂõæ: ${subChart.constructor.name}`);
            }
            
            loadData(codes, selectedIndicators) {
                // Ê∏ÖÈô§Áé∞ÊúâÊï∞ÊçÆ
                this.candleSeries = [];
                this.indicatorSeries = [];
                
                codes.forEach((code, idx) => {
                    fetch(`/api/kline?code=${code}`).then(r => r.json()).then(ohlc => {
                        // ‰øùÂ≠òÁ¨¨‰∏ÄÂè™ËÇ°Á•®ÁöÑÊï∞ÊçÆ
                        if (idx === 0) {
                            this.currentOhlcData = ohlc;
                        }
                        
                        // ÂàõÂª∫KÁ∫øÁ≥ªÂàó
                        const candleSeries = this.addSeries('candlestick', {
                            priceScaleId: 'right',
                            scaleMargins: { top: 0.2, bottom: 0.3 },
                            upColor: idx === 0 ? '#26a69a' : '#2196f3',
                            downColor: idx === 0 ? '#ef5350' : '#9c27b0',
                            borderUpColor: idx === 0 ? '#26a69a' : '#2196f3',
                            borderDownColor: idx === 0 ? '#ef5350' : '#9c27b0',
                            wickUpColor: idx === 0 ? '#26a69a' : '#2196f3',
                            wickDownColor: idx === 0 ? '#ef5350' : '#9c27b0'
                        });
                        candleSeries.setData(ohlc);
                        this.candleSeries.push(candleSeries);
                        
                        // Êàê‰∫§ÈáèÂè™ÊòæÁ§∫Á¨¨‰∏ÄÂè™ËÇ°Á•®ÁöÑ
                        if (idx === 0) {
                            const volumeData = ohlc.map(bar => ({
                                time: bar.time,
                                value: Number(bar.volume),
                                color: bar.close >= bar.open ? '#26a69a' : '#ef5350'
                            }));
                            this.volumeSeries.setData(volumeData);
                        }
                        
                        // Âä†ËΩΩÊåáÊ†á
                        if (idx === 0) {
                            this.loadIndicators(code, selectedIndicators, candleSeries);
                        }
                    });
                });
            }
            
            loadIndicators(code, selectedIndicators, candleSeries) {
                selectedIndicators.forEach(indicator => {
                    if (indicator === 'squeeze_momentum') {
                        // ÂàõÂª∫Squeeze MomentumÂ≠êÂõæ
                        this.createSqueezeChart(code);
                        return;
                    }
                    
                    fetch(`/api/indicator?code=${code}&type=${indicator}`)
                    .then(r => r.json()).then(ind => {
                        if (indicator === 'supertrend') {
                            this.addSupertrendIndicator(ind, candleSeries);
                        } else if (indicator.startsWith('ma')) {
                            this.addMAIndicator(ind, indicator);
                        }
                    });
                });
            }
            
            addSupertrendIndicator(data, candleSeries) {
                let segments = [], current = [], lastTrend = null;
                data.forEach(item => {
                    if (item.supertrend === null || isNaN(item.supertrend)) {
                        if (current.length) { 
                            segments.push({ trend: lastTrend, data: current }); 
                            current = []; 
                        }
                        lastTrend = null; 
                        return;
                    }
                    if (item.trend !== lastTrend && current.length) {
                        segments.push({ trend: lastTrend, data: current }); 
                        current = [];
                    }
                    current.push({ time: item.time, value: item.supertrend });
                    lastTrend = item.trend;
                });
                if (current.length) segments.push({ trend: lastTrend, data: current });
                
                segments.forEach(seg => {
                    const series = this.addSeries('line', {
                        color: seg.trend === 1 ? '#26a69a' : '#ef5350',
                        lineWidth: 2
                    });
                    series.setData(seg.data);
                    this.indicatorSeries.push(series);
                });
                
                // Ê∑ªÂä†‰π∞Âçñ‰ø°Âè∑Ê†áËÆ∞
                const markers = data.filter(item => item.signal).map(item => ({
                    time: item.time,
                    position: item.signal === 'buy' ? 'belowBar' : 'aboveBar',
                    color: item.signal === 'buy' ? '#26a69a' : '#ef5350',
                    shape: item.signal === 'buy' ? 'arrowUp' : 'arrowDown',
                    text: item.signal === 'buy' ? 'B' : 'S'
                }));
                candleSeries.setMarkers(markers);
            }
            
            addMAIndicator(data, indicator) {
                const maData = data.filter(item => item.ma !== null && !isNaN(item.ma))
                    .map(item => ({ time: item.time, value: Number(item.ma) }));
                
                const color = indicator === 'ma5' ? '#ff9800' : '#9c27b0';
                const series = this.addSeries('line', { color, lineWidth: 1 });
                series.setData(maData);
                this.indicatorSeries.push(series);
            }
            
            createSqueezeChart(code) {
                // ÂàõÂª∫Squeeze MomentumÂ≠êÂõæÂÆπÂô®
                const existingChart = document.getElementById('squeeze-chart');
                if (existingChart) {
                    existingChart.remove();
                }
                
                const squeezeContainer = document.createElement('div');
                squeezeContainer.id = 'squeeze-chart';
                squeezeContainer.style.width = '1000px';
                squeezeContainer.style.height = '200px';
                squeezeContainer.style.marginTop = '8px';
                document.getElementById('volume-chart').parentNode.insertBefore(
                    squeezeContainer, 
                    document.getElementById('volume-chart').nextSibling
                );
                
                // ÂàõÂª∫Â≠êÂõæÂÆû‰æã
                const squeezeChart = new SqueezeChart(squeezeContainer);
                squeezeChart.setMainChart(this);
                squeezeChart.create();
                squeezeChart.loadData(code);
                
                // ‰øùÂ≠òÂ≠êÂõæÂÆû‰æãÂà∞‰∏ªÂõæÁöÑÂ≠êÂõæÂàóË°®
                this.addSubChart(squeezeChart);
                
                // ‰øùÂ≠òÂà∞ÂÖ®Â±ÄÂèòÈáèÔºàÂÖºÂÆπÊÄßÔºâ
                window.squeezeChart = squeezeChart.chart;
                window.squeezeChartInstance = squeezeChart;
                
                console.log('SqueezeÂ≠êÂõæÂàõÂª∫ÂÆåÊàêÔºåÂ∑≤Ê∑ªÂä†Âà∞‰∏ªÂõæÁÆ°ÁêÜ');
            }
            
            handleCrosshairMove(param) {
                if (!param || !param.time) {
                    document.getElementById('info-bar').innerText = '';
                    return;
                }
                
                // ‰ºòÂÖà‰ΩøÁî®seriesPricesËé∑ÂèñÊï∞ÊçÆ
                if (param.seriesPrices) {
                    for (const value of param.seriesPrices.values()) {
                        if (value && typeof value.open !== 'undefined' && 
                            typeof value.high !== 'undefined' && 
                            typeof value.low !== 'undefined' && 
                            typeof value.close !== 'undefined') {
                            updateInfoBar(value);
                            return;
                        }
                    }
                }
                
                // Â§áÁî®ÊñπÊ≥ïÔºö‰ªéÂéüÂßãÊï∞ÊçÆ‰∏≠Êü•Êâæ
                if (this.currentOhlcData) {
                    const dataPoint = this.currentOhlcData.find(item => item.time === param.time);
                    if (dataPoint) {
                        updateInfoBar(dataPoint);
                        return;
                    }
                }
                
                document.getElementById('info-bar').innerText = '';
            }
        }
        
        // ===== Â≠êÂõæÂü∫Á±ª =====
        class SubChart extends BaseChart {
            constructor(container, options = {}) {
                super(container, {
                    height: 200,
                    ...options
                });
                this.mainChart = null;
            }
            
            setMainChart(mainChart) {
                this.mainChart = mainChart;
                console.log(`${this.constructor.name} ËÆæÁΩÆ‰∏ªÂõæÂÖ≥ËÅî`);
            }
            
            onCreated() {
                // ÁõëÂê¨Êó∂Èó¥ËΩ¥ÂèòÂåñÔºåÂêåÊ≠•Âà∞‰∏ªÂõæ
                this.subscribeTimeRangeChange((timeRange) => {
                    if (!window.isUpdatingFromGlobal && timeRange) {
                        detectAndSyncZoom(timeRange, 'squeeze');
                    }
                });
            }
        }
        
        // ===== Squeeze Momentum Â≠êÂõæ =====
        class SqueezeChart extends SubChart {
            constructor(container) {
                super(container, {
                    timeScale: {
                        visible: true,
                        timeVisible: true,
                        secondsVisible: false,
                        borderVisible: true,
                        rightOffset: 12,
                        barSpacing: 3,
                        fixLeftEdge: false,
                        fixRightEdge: false,
                        lockVisibleTimeRangeOnResize: true
                    }
                });
                this.momentumSeries = null;
                this.zeroLineSeries = null;
            }
            
            loadData(code) {
                fetch(`/api/indicator?code=${code}&type=squeeze_momentum`)
                .then(r => r.json()).then(data => {
                    console.log('Squeeze Â≠êÂõæÂä†ËΩΩÊï∞ÊçÆ:', data.length, 'Êù°');
                    
                    // Â§ÑÁêÜÂä®ÈáèÊü±Áä∂ÂõæÊï∞ÊçÆ
                    const momentumData = data.filter(item => item.momentum !== null && !isNaN(item.momentum))
                        .map(item => ({
                            time: item.time,
                            value: Number(item.momentum),
                            color: item.bar_color === 'lime' ? '#00ff00' : 
                                   item.bar_color === 'green' ? '#008000' :
                                   item.bar_color === 'red' ? '#ff0000' : '#800000'
                        }));
                    
                    // Ê∑ªÂä†Âä®ÈáèÊü±Áä∂Âõæ
                    this.momentumSeries = this.addSeries('histogram', {
                        priceFormat: { type: 'price', precision: 4, minMove: 0.0001 }
                    });
                    this.momentumSeries.setData(momentumData);
                    
                    // Ê∑ªÂä†Èõ∂ËΩ¥Á∫ø
                    const zeroLineData = data.map(item => ({
                        time: item.time,
                        value: 0
                    }));
                    
                    this.zeroLineSeries = this.addSeries('line', {
                        color: '#666666',
                        lineWidth: 1,
                        lineStyle: 2
                    });
                    this.zeroLineSeries.setData(zeroLineData);
                    
                    // Ê∑ªÂä†Êå§ÂéãÁä∂ÊÄÅÊ†áËÆ∞
                    this.addSqueezeMarkers(data);
                    
                    // ÂàùÂßãÂêåÊ≠•
                    this.initialSync();
                });
            }
            
            addSqueezeMarkers(data) {
                const squeezeMarkers = [];
                let lastSqueezeState = null;
                
                data.forEach(item => {
                    let currentState = null;
                    if (item.squeeze_on === 1) currentState = 'on';
                    else if (item.squeeze_off === 1) currentState = 'off';
                    else if (item.no_squeeze === 1) currentState = 'no';
                    
                    // Âè™Âú®Áä∂ÊÄÅÂèòÂåñÊó∂Ê∑ªÂä†Ê†áËÆ∞
                    if (currentState && currentState !== lastSqueezeState) {
                        squeezeMarkers.push({
                            time: item.time,
                            position: 'inBar',
                            color: item.squeeze_color === 'black' ? '#000000' :
                                   item.squeeze_color === 'gray' ? '#808080' : '#0000ff',
                            shape: 'circle',
                            size: 2
                        });
                        lastSqueezeState = currentState;
                    }
                });
                
                if (this.momentumSeries) {
                    this.momentumSeries.setMarkers(squeezeMarkers);
                }
            }
            
            initialSync() {
                console.log('üîÑ ÂºÄÂßãSqueezeÂ≠êÂõæÂàùÂßãÂêåÊ≠•');
                setTimeout(() => {
                    if (this.mainChart) {
                        const mainTimeRange = this.mainChart.getTimeRange();
                        if (mainTimeRange) {
                            console.log('üìä Squeeze Â≠êÂõæÂàùÂßãÂêåÊ≠• - ‰∏ªÂõæÊó∂Èó¥ËåÉÂõ¥:', mainTimeRange);
                            
                            // ‰∏¥Êó∂Á¶ÅÁî®ÂÖ®Â±ÄÊõ¥Êñ∞Ê†áÂøóÔºåÈÅøÂÖçÂæ™ÁéØÂêåÊ≠•
                            const wasUpdating = window.isUpdatingFromGlobal;
                            window.isUpdatingFromGlobal = true;
                            
                            try {
                                this.setTimeRange(mainTimeRange);
                                console.log('‚úÖ Squeeze Â≠êÂõæÊó∂Èó¥ËåÉÂõ¥ËÆæÁΩÆÂÆåÊàê');
                            } catch (e) {
                                console.error('‚ùå Squeeze Â≠êÂõæÊó∂Èó¥ËåÉÂõ¥ËÆæÁΩÆÂ§±Ë¥•:', e);
                            }
                            
                            // ÊÅ¢Â§çÊõ¥Êñ∞Ê†áÂøó
                            setTimeout(() => {
                                window.isUpdatingFromGlobal = wasUpdating;
                            }, 50);
                            
                            // È™åËØÅÂêåÊ≠•ÁªìÊûú
                            setTimeout(() => {
                                const myRange = this.getTimeRange();
                                if (mainTimeRange && myRange) {
                                    const fromDiff = Math.abs(mainTimeRange.from - myRange.from);
                                    const toDiff = Math.abs(mainTimeRange.to - myRange.to);
                                    const success = fromDiff < 0.1 && toDiff < 0.1;
                                    
                                    console.log('üîç Squeeze ÂàùÂßãÂêåÊ≠•È™åËØÅ:', {
                                        success: success,
                                        fromDiff: fromDiff.toFixed(4),
                                        toDiff: toDiff.toFixed(4),
                                        mainRange: mainTimeRange,
                                        myRange: myRange
                                    });
                                    
                                    if (!success) {
                                        console.warn('‚ö†Ô∏è Squeeze ÂàùÂßãÂêåÊ≠•ÂèØËÉΩÂ≠òÂú®ÂÅèÂ∑ÆÔºåÂ∞ùËØïÈáçÊñ∞ÂêåÊ≠•');
                                        // ÈáçËØï‰∏ÄÊ¨°
                                        setTimeout(() => {
                                            try {
                                                this.setTimeRange(mainTimeRange);
                                            } catch (e) {
                                                console.error('‚ùå Squeeze ÈáçËØïÂêåÊ≠•Â§±Ë¥•:', e);
                                            }
                                        }, 100);
                                    }
                                } else {
                                    console.warn('‚ö†Ô∏è Squeeze ÂàùÂßãÂêåÊ≠•È™åËØÅÂ§±Ë¥• - Êó†Ê≥ïËé∑ÂèñÊó∂Èó¥ËåÉÂõ¥');
                                }
                            }, 150);
                        } else {
                            console.warn('‚ö†Ô∏è Squeeze ÂàùÂßãÂêåÊ≠•Â§±Ë¥• - Êó†Ê≥ïËé∑Âèñ‰∏ªÂõæÊó∂Èó¥ËåÉÂõ¥');
                        }
                    } else {
                        console.warn('‚ö†Ô∏è Squeeze ÂàùÂßãÂêåÊ≠•Â§±Ë¥• - ‰∏ªÂõæÊú™ËÆæÁΩÆ');
                    }
                }, 300); // Â¢ûÂä†Âª∂ËøüÔºåÁ°Æ‰øù‰∏ªÂõæÂÆåÂÖ®Âä†ËΩΩ
            }
        }
        
        // ===== ÂõæË°®ÁÆ°ÁêÜÂô® =====
        class ChartManager {
            constructor() {
                this.mainChart = null;
                this.subCharts = [];
            }
            
            createMainChart(container) {
                if (this.mainChart) {
                    this.mainChart.destroy();
                }
                this.mainChart = new MainChart(container);
                this.mainChart.create();
                return this.mainChart;
            }
            
            addSubChart(subChart) {
                this.subCharts.push(subChart);
                if (this.mainChart) {
                    this.mainChart.addSubChart(subChart);
                }
            }
            
            loadData(codes, selectedIndicators) {
                if (this.mainChart) {
                    this.mainChart.loadData(codes, selectedIndicators);
                }
            }
            
            destroy() {
                if (this.mainChart) {
                    this.mainChart.destroy();
                    this.mainChart = null;
                }
                this.subCharts.forEach(chart => chart.destroy());
                this.subCharts = [];
            }
        }
        
        // ÂÖ®Â±ÄÂèòÈáè
        let chartManager = null;
        let loadChartTimeout = null;
        
        // ÂàùÂßãÂåñÂÖ®Â±ÄÂèòÈáè
        window.globalTimeRange = null;
        window.isUpdatingFromGlobal = false;
        window.lastSyncTime = 0;
        window.syncThrottleDelay = 150;
        window.lastTimeRange = null;
        
        // Êô∫ËÉΩÈò≤ÊäñÂêåÊ≠•ÂáΩÊï∞
        const debouncedSync = debounce((timeRange, source) => {
            if (!timeRange || !timeRange.from || !timeRange.to) {
                return;
            }
            
            const convertTimeToNumber = (time) => {
                if (typeof time === 'number') return time;
                if (typeof time === 'string') return new Date(time).getTime() / 1000;
                return time;
            };
            
            const currentTime = Date.now();
            if (currentTime - window.lastSyncTime < 30) {
                return;
            }
            
            const currentRange = window.globalTimeRange || {};
            const newFrom = convertTimeToNumber(timeRange.from);
            const newTo = convertTimeToNumber(timeRange.to);
            const currentFrom = convertTimeToNumber(currentRange.from);
            const currentTo = convertTimeToNumber(currentRange.to);
            
            const timeDiff = Math.abs(newFrom - currentFrom) + Math.abs(newTo - currentTo);
            
            if (timeDiff < 1800) {
                return;
            }
            
            window.lastSyncTime = currentTime;
            updateGlobalTimeRange(timeRange, source);
        }, 30);
        
        // ÂÖ®Â±ÄÊó∂Èó¥ËåÉÂõ¥Êõ¥Êñ∞ÂáΩÊï∞
        function updateGlobalTimeRange(timeRange, source) {
            if (!timeRange || !timeRange.from || !timeRange.to) {
                return;
            }
            
            const convertTimeToNumber = (time) => {
                if (typeof time === 'number') return time;
                if (typeof time === 'string') return new Date(time).getTime() / 1000;
                return time;
            };
            
            const currentRange = window.globalTimeRange || {};
            const newFrom = convertTimeToNumber(timeRange.from);
            const newTo = convertTimeToNumber(timeRange.to);
            const currentFrom = convertTimeToNumber(currentRange.from);
            const currentTo = convertTimeToNumber(currentRange.to);
            
            const timeDiff = Math.abs(newFrom - currentFrom) + Math.abs(newTo - currentTo);
            
            if (timeDiff < 1800) {
                return;
            }
            
            window.globalTimeRange = timeRange;
            window.isUpdatingFromGlobal = true;
            
            try {
                if (chartManager && chartManager.mainChart && chartManager.mainChart.chart) {
                    // ÂêåÊ≠•ÊâÄÊúâÂ≠êÂõæ
                    if (chartManager.mainChart.subCharts && chartManager.mainChart.subCharts.length > 0) {
                        chartManager.mainChart.subCharts.forEach(subChart => {
                            if (subChart && subChart.chart && subChart !== chartManager.mainChart) {
                                try {
                                    subChart.setTimeRange(timeRange);
                                } catch (error) {
                                    // ÈùôÈªòÂ§ÑÁêÜÈîôËØØ
                                }
                            }
                        });
                    }
                }
                
                // ÂÖºÂÆπÊÄßÔºöÂêåÊ≠•ÊóßÁâàÊú¨ÁöÑsqueezeÂõæË°®
                if (window.squeezeChart && source !== 'squeeze') {
                    try {
                        window.squeezeChart.timeScale().setVisibleRange(timeRange);
                    } catch (e) {
                        // ÈùôÈªòÂ§ÑÁêÜÈîôËØØ
                    }
                }
            } catch (error) {
                // ÈùôÈªòÂ§ÑÁêÜÈîôËØØ
            } finally {
                setTimeout(() => {
                    window.isUpdatingFromGlobal = false;
                }, 100);
            }
        }
        
        // Êõ¥Êñ∞‰ø°ÊÅØÊ†èÊòæÁ§∫
        function updateInfoBar(ohlcData) {
            const open = Number(ohlcData.open);
            const high = Number(ohlcData.high);
            const low = Number(ohlcData.low);
            const close = Number(ohlcData.close);
            const change = close - open;
            const pct = open ? (change / open * 100).toFixed(2) : '0.00';
            const sign = change >= 0 ? '+' : '';
            
            // ‰ªéÊï∞ÊçÆ‰∏≠Ëé∑ÂèñÊç¢ÊâãÁéáÂπ∂ËΩ¨Êç¢‰∏∫ÁôæÂàÜÊØî
            const turnoverRate = ohlcData.turnover_rate ? (Number(ohlcData.turnover_rate) * 100).toFixed(2) : '0.00';
            
            document.getElementById('info-bar').innerHTML =
                `ÂºÄ=${open.toFixed(2)}, È´ò=${high.toFixed(2)}, ‰Ωé=${low.toFixed(2)}, Êî∂=${close.toFixed(2)}, ` +
                `<span style="color:${change>=0?'#26a69a':'#ef5350'}">${sign}${change.toFixed(2)} (${sign}${pct}%)</span>, ` +
                `Êç¢ÊâãÁéá=${turnoverRate}%`;
        }
        
        // Á§∫‰æãËÇ°Á•®ÂàóË°®ÔºàÂèØÊõøÊç¢‰∏∫ÂêéÁ´ØAPIÔºâ
        const stockList = [
            { id: 'HK.09660', text: '9660 HORIZON ROBOTICS' },
            { id: 'SZ.000001', text: '000001 Âπ≥ÂÆâÈì∂Ë°å' },
            { id: 'SH.600519', text: '600519 Ë¥µÂ∑ûËåÖÂè∞' }
            // ...Êõ¥Â§ö
        ];
        
        $(document).ready(function() {
            $('#code').select2({
                data: stockList,
                placeholder: 'ËæìÂÖ•‰ª£Á†Å/ÂêçÁß∞ÊêúÁ¥¢',
                allowClear: true
            });
            // ÁªëÂÆöcheckboxÂàáÊç¢‰∫ã‰ª∂
            document.querySelectorAll('.indicator').forEach(cb => {
                cb.removeEventListener('change', loadChart);
                cb.addEventListener('change', loadChart);
            });
        });
        
        function loadChart() {
            // Ê∏ÖÈô§‰πãÂâçÁöÑÈò≤ÊäñÂÆöÊó∂Âô®
            if (loadChartTimeout) {
                clearTimeout(loadChartTimeout);
            }
            
            // ËÆæÁΩÆÈò≤ÊäñÔºå300msÂÜÖÂè™ÊâßË°åÊúÄÂêé‰∏ÄÊ¨°Ë∞ÉÁî®
            loadChartTimeout = setTimeout(() => {
                executeLoadChart();
            }, 300);
        }
        
        function executeLoadChart() {
            // Ê∏ÖÁêÜÁé∞ÊúâÂõæË°®
            if (chartManager) {
                chartManager.destroy();
            }
            
            // Ê∏ÖÁêÜDOM
            document.getElementById('chart').innerHTML = '';
            document.getElementById('info-bar').innerText = '';
            
            const existingSqueezeChart = document.getElementById('squeeze-chart');
            if (existingSqueezeChart) {
                existingSqueezeChart.remove();
            }
            
            // ÂàõÂª∫Êñ∞ÁöÑÂõæË°®ÁÆ°ÁêÜÂô®
            chartManager = new ChartManager();
            
            // ÂàõÂª∫‰∏ªÂõæ
            chartManager.createMainChart(document.getElementById('chart'));
            
            // Ëé∑ÂèñÈÄâ‰∏≠ÁöÑËÇ°Á•®ÂíåÊåáÊ†á
            const codes = $('#code').val() || [];
            const selectedIndicators = Array.from(document.querySelectorAll('.indicator:checked')).map(el => el.value);
            
            // Âä†ËΩΩÊï∞ÊçÆ
            if (codes.length > 0) {
                chartManager.loadData(codes, selectedIndicators);
            }
        }
        
        // Èò≤ÊäñÂáΩÊï∞
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Áº©ÊîæÊ£ÄÊµãÂíåÂêåÊ≠•ÂáΩÊï∞
        function detectAndSyncZoom(timeRange, source) {
            if (!timeRange || !timeRange.from || !timeRange.to) {
                debouncedSync(timeRange, source);
                return;
            }
            
            const convertTimeToNumber = (time) => {
                if (typeof time === 'number') return time;
                if (typeof time === 'string') return new Date(time).getTime() / 1000;
                return time;
            };
            
            const currentRange = window.lastTimeRange || {};
            const newRange = timeRange;
            
            if (!currentRange.from || !currentRange.to) {
                window.lastTimeRange = newRange;
                debouncedSync(timeRange, source);
                return;
            }
            
            const currentFrom = convertTimeToNumber(currentRange.from);
            const currentTo = convertTimeToNumber(currentRange.to);
            const newFrom = convertTimeToNumber(newRange.from);
            const newTo = convertTimeToNumber(newRange.to);
            
            const currentSpan = currentTo - currentFrom;
            const newSpan = newTo - newFrom;
            const spanRatio = newSpan / currentSpan;
            
            let operationType = 'pan';
            if (spanRatio < 0.95) {
                operationType = 'zoom-in';
            } else if (spanRatio > 1.05) {
                operationType = 'zoom-out';
            }
            
            window.lastTimeRange = newRange;
            
            if (operationType === 'zoom-out') {
                window.lastSyncTime = 0;
            }
            
            debouncedSync(timeRange, source);
        }

        // Âº∫Âà∂ÂêåÊ≠•ÂõæË°®ÂáΩÊï∞
        function forceSyncCharts() {
            if (!chartManager || !chartManager.mainChart) {
                alert('ËØ∑ÂÖàÂä†ËΩΩÂõæË°®');
                return;
            }
            
            const mainTimeRange = chartManager.mainChart.getTimeRange();
            if (!mainTimeRange) {
                alert('Êó†Ê≥ïËé∑Âèñ‰∏ªÂõæÊó∂Èó¥ËåÉÂõ¥');
                return;
            }
            
            // Âº∫Âà∂Êõ¥Êñ∞ÂÖ®Â±ÄÊó∂Èó¥ËåÉÂõ¥
            window.globalTimeRange = mainTimeRange;
            window.isUpdatingFromGlobal = true;
            
            try {
                // ÂêåÊ≠•ÊâÄÊúâÂ≠êÂõæ
                if (chartManager.mainChart.subCharts && chartManager.mainChart.subCharts.length > 0) {
                    chartManager.mainChart.subCharts.forEach((subChart) => {
                        try {
                            subChart.setTimeRange(mainTimeRange);
                        } catch (e) {
                            // ÈùôÈªòÂ§ÑÁêÜÈîôËØØ
                        }
                    });
                }
                
                // ÂÖºÂÆπÊÄßÔºöÂêåÊ≠•ÊóßÁâàÊú¨ÁöÑsqueezeÂõæË°®
                if (window.squeezeChart) {
                    try {
                        window.squeezeChart.timeScale().setVisibleRange(mainTimeRange);
                    } catch (e) {
                        // ÈùôÈªòÂ§ÑÁêÜÈîôËØØ
                    }
                }
                
                alert('ÂõæË°®ÂêåÊ≠•ÂÆåÊàê');
                
            } catch (error) {
                alert('ÂêåÊ≠•ËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ');
            } finally {
                setTimeout(() => {
                    window.isUpdatingFromGlobal = false;
                }, 100);
            }
        }
    </script>
</body>
</html> 