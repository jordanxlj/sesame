<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LightweightCharts é€»è¾‘èŒƒå›´è°ƒè¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .debug-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 4px;
        }
        button {
            margin: 5px;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        .chart-container {
            height: 400px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>LightweightCharts é€»è¾‘èŒƒå›´è°ƒè¯•å·¥å…·</h1>
        
        <div class="controls">
            <button onclick="startDebugTest()">å¼€å§‹è°ƒè¯•æµ‹è¯•</button>
            <button onclick="clearDebugLog()">æ¸…ç©ºæ—¥å¿—</button>
            <button onclick="logCurrentState()">è®°å½•å½“å‰çŠ¶æ€</button>
            <button onclick="testDirectSeries()">ç›´æ¥æµ‹è¯•ç³»åˆ—åˆ›å»º</button>
            <button onclick="testBasicLightweightCharts()">æµ‹è¯•åŸºç¡€ LightweightCharts API</button>
            <button onclick="testHK01810()">æµ‹è¯• HK.01810 è‚¡ç¥¨æ•°æ®</button>
            <button onclick="testMultiStockAlignment()">æµ‹è¯•å¤šè‚¡ç¥¨å¯¹é½</button>
            <button onclick="test01810SpecificIssues()">æµ‹è¯• 01810 ç‰¹å®šé—®é¢˜</button>
        </div>
        
        <div id="debug-log" class="debug-info">
            è°ƒè¯•æ—¥å¿—å°†åœ¨è¿™é‡Œæ˜¾ç¤º...
        </div>
        
        <div id="test-results" class="debug-info" style="background: #e8f5e8; border-color: #d4edda;">
            <h4 style="margin: 0 0 10px 0; color: #155724;">HK.01810 æµ‹è¯•ç»“æœ</h4>
            <div id="test-results-content">ç­‰å¾…æµ‹è¯•ç»“æœ...</div>
        </div>
        
        <div id="main-chart" class="chart-container"></div>
        <div id="volume-chart" class="chart-container" style="height: 150px;"></div>
    </div>

    <!-- å¼•å…¥ LightweightCharts åº“ -->
    <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
    <!-- å¼•å…¥æˆ‘ä»¬çš„å›¾è¡¨åº“ -->
    <script src="static/lightweight-charts.js"></script>

    <script>
        let debugLog = [];
        let mainChart = null;
        let volumeChart = null;
        let testResults = [];

        // é‡å†™ console.log æ¥æ•è·è°ƒè¯•ä¿¡æ¯
        const originalConsoleLog = console.log;
        const originalConsoleWarn = console.warn;
        const originalConsoleError = console.error;

        function captureLog(type, args) {
            const timestamp = new Date().toLocaleTimeString();
            const message = Array.from(args).map(arg => 
                typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
            ).join(' ');
            
            debugLog.push(`[${timestamp}] ${type}: ${message}`);
            updateDebugDisplay();
            
            // é™åˆ¶æ—¥å¿—æ•°é‡
            if (debugLog.length > 100) {
                debugLog = debugLog.slice(-80);
            }
        }

        console.log = function(...args) {
            captureLog('LOG', args);
            originalConsoleLog.apply(console, args);
        };

        console.warn = function(...args) {
            captureLog('WARN', args);
            originalConsoleWarn.apply(console, args);
        };

        console.error = function(...args) {
            captureLog('ERROR', args);
            originalConsoleError.apply(console, args);
        };

        function updateDebugDisplay() {
            const debugElement = document.getElementById('debug-log');
            if (debugElement) {
                debugElement.innerHTML = debugLog.slice(-20).join('\n');
                debugElement.scrollTop = debugElement.scrollHeight;
            }
        }

        function clearDebugLog() {
            debugLog = [];
            updateDebugDisplay();
        }

        function logCurrentState() {
            if (mainChart && mainChart.chart) {
                const logicalRange = mainChart.chart.timeScale().getVisibleLogicalRange();
                const visibleRange = mainChart.chart.timeScale().getVisibleRange();
                const timeScaleOptions = mainChart.chart.timeScale().options();
                
                console.log('ğŸ” [MANUAL] å½“å‰ä¸»å›¾çŠ¶æ€:', {
                    logicalRange,
                    visibleRange,
                    barSpacing: timeScaleOptions.barSpacing,
                    seriesCount: mainChart.series.length
                });
            }
            
            if (volumeChart && volumeChart.chart) {
                const volLogicalRange = volumeChart.chart.timeScale().getVisibleLogicalRange();
                const volVisibleRange = volumeChart.chart.timeScale().getVisibleRange();
                
                console.log('ğŸ” [MANUAL] å½“å‰æˆäº¤é‡å›¾çŠ¶æ€:', {
                    logicalRange: volLogicalRange,
                    visibleRange: volVisibleRange,
                    seriesCount: volumeChart.series.length
                });
            }
        }

        async function startDebugTest() {
            console.log('ğŸš€ å¼€å§‹è°ƒè¯•æµ‹è¯•...');
            
            try {
                // æ¸…ç†ç°æœ‰å›¾è¡¨
                if (mainChart) {
                    mainChart.destroy();
                    mainChart = null;
                }
                if (volumeChart) {
                    volumeChart.destroy();
                    volumeChart = null;
                }
                
                // åˆ›å»ºä¸»å›¾
                const mainContainer = document.getElementById('main-chart');
                mainChart = new MainChart(mainContainer);
                mainChart.create();
                
                // ğŸ” DEBUG: æ£€æŸ¥ LightweightCharts å®é™…å¯ç”¨çš„æ–¹æ³•
                console.log('ğŸ” [API-CHECK] LightweightCharts å…¨å±€å¯¹è±¡:', window.LightweightCharts);
                console.log('ğŸ” [API-CHECK] ä¸»å›¾chartå¯¹è±¡æ–¹æ³•:', Object.getOwnPropertyNames(mainChart.chart).filter(name => typeof mainChart.chart[name] === 'function'));
                console.log('ğŸ” [API-CHECK] ä¸»å›¾chartåŸå‹æ–¹æ³•:', Object.getOwnPropertyNames(Object.getPrototypeOf(mainChart.chart)).filter(name => typeof mainChart.chart[name] === 'function'));
                
                // æ£€æŸ¥å…·ä½“çš„ç³»åˆ—åˆ›å»ºæ–¹æ³•
                const chartMethods = [
                    'addCandlestickSeries',
                    'addHistogramSeries', 
                    'addLineSeries',
                    'addAreaSeries',
                    'addBarSeries',
                    // å¯èƒ½çš„æ›¿ä»£æ–¹æ³•å
                    'addCandleSeries',
                    'addHistogram',
                    'addLine',
                    'addArea'
                ];
                
                chartMethods.forEach(method => {
                    console.log(`ğŸ” [API-CHECK] ${method}:`, typeof mainChart.chart[method]);
                });
                
                // åˆ›å»ºæˆäº¤é‡å›¾
                const volumeContainer = document.getElementById('volume-chart');
                volumeChart = new VolumeChart(volumeContainer);
                volumeChart.create();
                
                console.log('âœ… å›¾è¡¨åˆ›å»ºå®Œæˆ');
                
                // æ¨¡æ‹ŸåŠ è½½æ•°æ®
                await simulateDataLoad();
                
            } catch (error) {
                console.error('âŒ è°ƒè¯•æµ‹è¯•å¤±è´¥:', error);
            }
        }

        async function simulateDataLoad() {
            console.log('ğŸ“Š å¼€å§‹æ¨¡æ‹Ÿæ•°æ®åŠ è½½...');
            
            // æ¨¡æ‹ŸOHLCæ•°æ®
            const mockOhlcData = generateMockOhlcData();
            console.log('ğŸ” ç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®:', mockOhlcData.length, 'ä¸ªæ•°æ®ç‚¹');
            
            // æ­¥éª¤1: æ·»åŠ Kçº¿ç³»åˆ—
            console.log('ğŸ“ˆ æ­¥éª¤1: æ·»åŠ Kçº¿ç³»åˆ—');
            const candleSeries = mainChart.addSeries('candlestick', {
                priceScaleId: 'right',
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderUpColor: '#26a69a',
                borderDownColor: '#ef5350',
                wickUpColor: '#26a69a',
                wickDownColor: '#ef5350'
            });
            
            if (candleSeries) {
                console.log('ğŸ” Kçº¿ç³»åˆ—åˆ›å»ºåï¼Œè®¾ç½®æ•°æ®...');
                candleSeries.setData(mockOhlcData);
                console.log('âœ… Kçº¿æ•°æ®è®¾ç½®å®Œæˆ');
            }
            
            // ç­‰å¾…ä¸€ä¸ªåŠ¨ç”»å¸§
            await new Promise(resolve => requestAnimationFrame(resolve));
            
            // æ­¥éª¤2: æ·»åŠ æˆäº¤é‡ç³»åˆ—
            console.log('ğŸ“Š æ­¥éª¤2: æ·»åŠ æˆäº¤é‡ç³»åˆ—');
            const volumeData = mockOhlcData.map(item => ({
                time: item.time,
                value: Math.random() * 1000000,
                color: item.close >= item.open ? '#26a69a' : '#ef5350'
            }));
            
            const volumeSeries = volumeChart.addSeries('histogram', {
                priceScaleId: 'right',
                priceFormat: { type: 'volume' },
                color: '#26a69a'
            });
            
            if (volumeSeries) {
                console.log('ğŸ” æˆäº¤é‡ç³»åˆ—åˆ›å»ºåï¼Œè®¾ç½®æ•°æ®...');
                volumeSeries.setData(volumeData);
                console.log('âœ… æˆäº¤é‡æ•°æ®è®¾ç½®å®Œæˆ');
            }
            
            // ç­‰å¾…ä¸€ä¸ªåŠ¨ç”»å¸§
            await new Promise(resolve => requestAnimationFrame(resolve));
            
            console.log('âœ… æ¨¡æ‹Ÿæ•°æ®åŠ è½½å®Œæˆ');
            logCurrentState();
        }

        function generateMockOhlcData() {
            const data = [];
            const startDate = new Date('2024-01-01');
            let price = 100;
            
            for (let i = 0; i < 100; i++) {
                const date = new Date(startDate);
                date.setDate(date.getDate() + i);
                
                const open = price;
                const change = (Math.random() - 0.5) * 4;
                const close = open + change;
                const high = Math.max(open, close) + Math.random() * 2;
                const low = Math.min(open, close) - Math.random() * 2;
                
                data.push({
                    time: date.toISOString().split('T')[0],
                    open: parseFloat(open.toFixed(2)),
                    high: parseFloat(high.toFixed(2)),
                    low: parseFloat(low.toFixed(2)),
                    close: parseFloat(close.toFixed(2)),
                    volume: Math.floor(Math.random() * 1000000)
                });
                
                price = close;
            }
            
            return data;
        }

        async function testDirectSeries() {
            console.log('ğŸ§ª ç›´æ¥æµ‹è¯•ç³»åˆ—åˆ›å»ºå’Œæ•°æ®è®¾ç½®...');
            
            if (!mainChart) {
                console.error('âŒ ä¸»å›¾æœªåˆ›å»º');
                return;
            }
            
            try {
                // è®°å½•åˆå§‹çŠ¶æ€
                const beforeLogical = mainChart.chart.timeScale().getVisibleLogicalRange();
                console.log('ğŸ” [DIRECT] æµ‹è¯•å‰ logical range:', beforeLogical);
                
                // åˆ›å»ºä¸€ä¸ªç®€å•çš„çº¿æ¡ç³»åˆ—
                const lineSeries = mainChart.addSeries('line', {
                    color: '#ff0000',
                    lineWidth: 2
                });
                
                // è®°å½•åˆ›å»ºåçŠ¶æ€
                const afterCreateLogical = mainChart.chart.timeScale().getVisibleLogicalRange();
                console.log('ğŸ” [DIRECT] ç³»åˆ—åˆ›å»ºå logical range:', afterCreateLogical);
                
                // è®¾ç½®ç®€å•æ•°æ®
                const simpleData = [
                    { time: '2024-01-01', value: 100 },
                    { time: '2024-01-02', value: 110 },
                    { time: '2024-01-03', value: 105 },
                    { time: '2024-01-04', value: 115 },
                    { time: '2024-01-05', value: 120 }
                ];
                
                lineSeries.setData(simpleData);
                
                // è®°å½•æ•°æ®è®¾ç½®åçŠ¶æ€
                setTimeout(() => {
                    const afterDataLogical = mainChart.chart.timeScale().getVisibleLogicalRange();
                    console.log('ğŸ” [DIRECT] æ•°æ®è®¾ç½®å logical range:', afterDataLogical);
                    
                    // åˆ†æå˜åŒ–
                    if (beforeLogical && afterDataLogical) {
                        const fromDiff = Math.abs((beforeLogical.from || 0) - (afterDataLogical.from || 0));
                        const toDiff = Math.abs((beforeLogical.to || 0) - (afterDataLogical.to || 0));
                        
                        console.log('ğŸ” [DIRECT] é€»è¾‘èŒƒå›´å˜åŒ–åˆ†æ:', {
                            fromDiff,
                            toDiff,
                            beforeFrom: beforeLogical.from,
                            afterFrom: afterDataLogical.from,
                            isNegative: afterDataLogical.from < 0
                        });
                    }
                }, 50);
                
            } catch (error) {
                console.error('âŒ ç›´æ¥æµ‹è¯•å¤±è´¥:', error);
            }
        }

        function testBasicLightweightCharts() {
            console.log('ğŸ§ª æµ‹è¯•åŸºç¡€ LightweightCharts API...');
            
            try {
                // æ£€æŸ¥å…¨å±€å¯¹è±¡
                console.log('ğŸ” window.LightweightCharts:', window.LightweightCharts);
                console.log('ğŸ” typeof LightweightCharts:', typeof window.LightweightCharts);
                
                if (window.LightweightCharts) {
                    console.log('ğŸ” LightweightCharts æ–¹æ³•:', Object.keys(window.LightweightCharts));
                    
                    // å°è¯•åˆ›å»ºä¸€ä¸ªç®€å•çš„å›¾è¡¨
                    const container = document.createElement('div');
                    container.style.width = '400px';
                    container.style.height = '300px';
                    document.body.appendChild(container);
                    
                    const chart = LightweightCharts.createChart(container, {
                        width: 400,
                        height: 300
                    });
                    
                    console.log('âœ… åŸºç¡€å›¾è¡¨åˆ›å»ºæˆåŠŸ');
                    console.log('ğŸ” chart å¯¹è±¡:', chart);
                    console.log('ğŸ” chart æ–¹æ³•:', Object.getOwnPropertyNames(chart).filter(name => typeof chart[name] === 'function'));
                    console.log('ğŸ” chart åŸå‹æ–¹æ³•:', Object.getOwnPropertyNames(Object.getPrototypeOf(chart)).filter(name => typeof chart[name] === 'function'));
                    
                    // æµ‹è¯•ç³»åˆ—åˆ›å»ºæ–¹æ³•
                    const testMethods = [
                        'addCandlestickSeries',
                        'addHistogramSeries',
                        'addLineSeries',
                        'addAreaSeries'
                    ];
                    
                    testMethods.forEach(method => {
                        if (typeof chart[method] === 'function') {
                            console.log(`âœ… ${method}: å¯ç”¨`);
                            try {
                                const series = chart[method]();
                                console.log(`âœ… ${method} åˆ›å»ºæˆåŠŸ:`, series);
                            } catch (e) {
                                console.log(`âš ï¸ ${method} åˆ›å»ºå¤±è´¥:`, e.message);
                            }
                        } else {
                            console.log(`âŒ ${method}: ä¸å¯ç”¨`);
                        }
                    });
                    
                    // æ¸…ç†
                    chart.remove();
                    document.body.removeChild(container);
                    
                } else {
                    console.error('âŒ LightweightCharts æœªåŠ è½½');
                }
                
            } catch (error) {
                console.error('âŒ åŸºç¡€æµ‹è¯•å¤±è´¥:', error);
            }
        }

        // æµ‹è¯• HK.01810 è‚¡ç¥¨æ•°æ®
        async function testHK01810() {
            console.log('ğŸ¯ å¼€å§‹æµ‹è¯• HK.01810 è‚¡ç¥¨æ•°æ®...');
            
            try {
                // æ¸…ç†ç°æœ‰å›¾è¡¨
                if (mainChart) {
                    mainChart.destroy();
                    mainChart = null;
                }
                if (volumeChart) {
                    volumeChart.destroy();
                    volumeChart = null;
                }
                
                // åˆ›å»ºä¸»å›¾
                const mainContainer = document.getElementById('main-chart');
                mainChart = new MainChart(mainContainer);
                mainChart.create();
                
                // åˆ›å»ºæˆäº¤é‡å›¾
                const volumeContainer = document.getElementById('volume-chart');
                volumeChart = new VolumeChart(volumeContainer);
                volumeChart.create();
                
                console.log('ğŸ“Š å›¾è¡¨åˆ›å»ºå®Œæˆï¼Œå¼€å§‹åŠ è½½ HK.01810 æ•°æ®...');
                
                // åŠ è½½ HK.01810 è‚¡ç¥¨æ•°æ®
                const response = await fetch('http://localhost:5000/api/kline?code=HK.01810');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const ohlcData = await response.json();
                console.log(`âœ… HK.01810 æ•°æ®è·å–æˆåŠŸï¼Œæ•°æ®é•¿åº¦: ${ohlcData.length}`);
                console.log('ğŸ“Š æ•°æ®æ ·æœ¬:', ohlcData.slice(0, 3));
                
                // è®°å½•æ•°æ®åŠ è½½å‰çš„é€»è¾‘èŒƒå›´
                const beforeDataLogical = mainChart.chart.timeScale().getVisibleLogicalRange();
                console.log('ğŸ” [01810] æ•°æ®åŠ è½½å‰ logical range:', beforeDataLogical);
                
                // ä½¿ç”¨ MainChart çš„ loadData æ–¹æ³•
                await mainChart.loadData(['HK.01810'], ['supertrend', 'ma5', 'ma10']);
                
                // åŒæ—¶åŠ è½½æˆäº¤é‡æ•°æ®åˆ° VolumeChart
                console.log('ğŸ“Š å¼€å§‹åŠ è½½æˆäº¤é‡æ•°æ®åˆ° VolumeChart...');
                await volumeChart.loadVolumeData('HK.01810');
                
                // è®°å½•æ•°æ®åŠ è½½åçš„é€»è¾‘èŒƒå›´
                setTimeout(() => {
                    const afterDataLogical = mainChart.chart.timeScale().getVisibleLogicalRange();
                    console.log('ğŸ” [01810] æ•°æ®åŠ è½½å logical range:', afterDataLogical);
                    
                    // æ£€æŸ¥æ—¶é—´è½´å¯¹é½
                    checkTimeAxisAlignment();
                    
                    // è®°å½•å½“å‰çŠ¶æ€
                    logCurrentState();
                }, 500);
                
                console.log('âœ… HK.01810 è‚¡ç¥¨æ•°æ®æµ‹è¯•å®Œæˆ');
                updateTestResults('HK.01810 å•è‚¡ç¥¨æµ‹è¯•', 'success', 'å•è‚¡ç¥¨æ•°æ®åŠ è½½å’Œæ—¶é—´è½´æ£€æŸ¥å®Œæˆ');
                
            } catch (error) {
                console.error('âŒ HK.01810 æµ‹è¯•å¤±è´¥:', error);
                updateTestResults('HK.01810 å•è‚¡ç¥¨æµ‹è¯•', 'error', `æµ‹è¯•å¤±è´¥: ${error.message}`);
            }
        }
        
        // æµ‹è¯•å¤šè‚¡ç¥¨å¯¹é½
        async function testMultiStockAlignment() {
            console.log('ğŸ¯ å¼€å§‹æµ‹è¯•å¤šè‚¡ç¥¨å¯¹é½...');
            
            try {
                // æ¸…ç†ç°æœ‰å›¾è¡¨
                if (mainChart) {
                    mainChart.destroy();
                    mainChart = null;
                }
                if (volumeChart) {
                    volumeChart.destroy();
                    volumeChart = null;
                }
                
                // åˆ›å»ºä¸»å›¾
                const mainContainer = document.getElementById('main-chart');
                mainChart = new MainChart(mainContainer);
                mainChart.create();
                
                // åˆ›å»ºæˆäº¤é‡å›¾
                const volumeContainer = document.getElementById('volume-chart');
                volumeChart = new VolumeChart(volumeContainer);
                volumeChart.create();
                
                console.log('ğŸ“Š å›¾è¡¨åˆ›å»ºå®Œæˆï¼Œå¼€å§‹åŠ è½½å¤šè‚¡ç¥¨æ•°æ®...');
                
                // åŠ è½½å¤šåªè‚¡ç¥¨æ•°æ®ï¼ˆåŒ…æ‹¬ 01810ï¼‰
                const stocks = ['HK.09660', 'HK.01810', 'HK.02432'];
                await mainChart.loadData(stocks, ['supertrend']);
                
                // åŠ è½½ä¸»è‚¡ç¥¨ï¼ˆç¬¬ä¸€åªè‚¡ç¥¨ï¼‰çš„æˆäº¤é‡æ•°æ®
                console.log('ğŸ“Š å¼€å§‹åŠ è½½ä¸»è‚¡ç¥¨æˆäº¤é‡æ•°æ®åˆ° VolumeChart...');
                await volumeChart.loadVolumeData(stocks[0]); // åŠ è½½ç¬¬ä¸€åªè‚¡ç¥¨çš„æˆäº¤é‡
                
                console.log('âœ… å¤šè‚¡ç¥¨æ•°æ®åŠ è½½å®Œæˆ');
                
                // ç­‰å¾…ä¸€æ®µæ—¶é—´åæ£€æŸ¥å¯¹é½
                setTimeout(() => {
                    console.log('ğŸ” æ£€æŸ¥å¤šè‚¡ç¥¨æ—¶é—´è½´å¯¹é½...');
                    checkTimeAxisAlignment();
                    logCurrentState();
                    
                    // ç‰¹åˆ«æ£€æŸ¥ 01810 çš„å¯è§æ€§
                    check01810Visibility();
                    updateTestResults('å¤šè‚¡ç¥¨å¯¹é½æµ‹è¯•', 'success', `åŠ è½½äº† ${stocks.length} åªè‚¡ç¥¨å¹¶æ£€æŸ¥å¯¹é½`);
                }, 1000);
                
            } catch (error) {
                console.error('âŒ å¤šè‚¡ç¥¨å¯¹é½æµ‹è¯•å¤±è´¥:', error);
                updateTestResults('å¤šè‚¡ç¥¨å¯¹é½æµ‹è¯•', 'error', `æµ‹è¯•å¤±è´¥: ${error.message}`);
            }
        }
        
        // æµ‹è¯• 01810 ç‰¹å®šé—®é¢˜
        async function test01810SpecificIssues() {
            console.log('ğŸ¯ å¼€å§‹æµ‹è¯• 01810 ç‰¹å®šé—®é¢˜...');
            
            try {
                // æ¸…ç†ç°æœ‰å›¾è¡¨
                if (mainChart) {
                    mainChart.destroy();
                    mainChart = null;
                }
                
                // åˆ›å»ºä¸»å›¾
                const mainContainer = document.getElementById('main-chart');
                mainChart = new MainChart(mainContainer);
                mainChart.create();
                
                console.log('ğŸ“Š å¼€å§‹é‡ç° 01810 æ•°æ®æˆªæ–­é—®é¢˜...');
                
                // åœºæ™¯1: ä¸‰åªè‚¡ç¥¨ä¸€èµ·åŠ è½½
                console.log('ğŸ§ª åœºæ™¯1: åŠ è½½ 09660, 01810, 02432');
                await mainChart.loadData(['HK.09660', 'HK.01810', 'HK.02432'], []);
                
                setTimeout(() => {
                    console.log('ğŸ” åœºæ™¯1 æ£€æŸ¥ç»“æœ:');
                    check01810DataRange('åœºæ™¯1');
                    
                    // åœºæ™¯2: éšè— 09660
                    console.log('ğŸ§ª åœºæ™¯2: éšè— 09660');
                    if (mainChart.toggleStockVisibility) {
                        mainChart.toggleStockVisibility(0); // éšè—ç¬¬ä¸€åªè‚¡ç¥¨(09660)
                        
                        setTimeout(() => {
                            console.log('ğŸ” åœºæ™¯2 æ£€æŸ¥ç»“æœ:');
                            check01810DataRange('åœºæ™¯2');
                            
                            // åœºæ™¯3: åªæ˜¾ç¤º 01810
                            console.log('ğŸ§ª åœºæ™¯3: åªæ˜¾ç¤º 01810');
                            mainChart.toggleStockVisibility(2); // éšè—ç¬¬ä¸‰åªè‚¡ç¥¨(02432)
                            
                            setTimeout(() => {
                                console.log('ğŸ” åœºæ™¯3 æ£€æŸ¥ç»“æœ:');
                                check01810DataRange('åœºæ™¯3');
                                updateTestResults('01810 ç‰¹å®šé—®é¢˜æµ‹è¯•', 'success', 'å®Œæˆä¸‰ä¸ªåœºæ™¯çš„æ•°æ®æˆªæ–­æµ‹è¯•');
                            }, 1000);
                        }, 1000);
                    }
                }, 1000);
                
            } catch (error) {
                console.error('âŒ 01810 ç‰¹å®šé—®é¢˜æµ‹è¯•å¤±è´¥:', error);
                updateTestResults('01810 ç‰¹å®šé—®é¢˜æµ‹è¯•', 'error', `æµ‹è¯•å¤±è´¥: ${error.message}`);
            }
        }
        
        // æ£€æŸ¥æ—¶é—´è½´å¯¹é½
        function checkTimeAxisAlignment() {
            if (!mainChart || !volumeChart) {
                console.warn('âš ï¸ å›¾è¡¨æœªåˆ›å»ºï¼Œæ— æ³•æ£€æŸ¥å¯¹é½');
                return;
            }
            
            const mainLogical = mainChart.chart.timeScale().getVisibleLogicalRange();
            const mainVisible = mainChart.chart.timeScale().getVisibleRange();
            const mainBarSpacing = mainChart.chart.timeScale().options().barSpacing;
            
            const volumeLogical = volumeChart.chart.timeScale().getVisibleLogicalRange();
            const volumeVisible = volumeChart.chart.timeScale().getVisibleRange();
            const volumeBarSpacing = volumeChart.chart.timeScale().options().barSpacing;
            
            console.log('ğŸ” [ALIGNMENT] ä¸»å›¾çŠ¶æ€:', {
                logical: mainLogical,
                visible: mainVisible,
                barSpacing: mainBarSpacing
            });
            
            console.log('ğŸ” [ALIGNMENT] æˆäº¤é‡å›¾çŠ¶æ€:', {
                logical: volumeLogical,
                visible: volumeVisible,
                barSpacing: volumeBarSpacing
            });
            
            // æ£€æŸ¥å¯¹é½å·®å¼‚
            const logicalFromDiff = Math.abs((mainLogical?.from || 0) - (volumeLogical?.from || 0));
            const logicalToDiff = Math.abs((mainLogical?.to || 0) - (volumeLogical?.to || 0));
            const spacingDiff = Math.abs(mainBarSpacing - volumeBarSpacing);
            
            if (logicalFromDiff > 0.1 || logicalToDiff > 0.1 || spacingDiff > 0.1) {
                console.warn('âš ï¸ [ALIGNMENT] å‘ç°å¯¹é½é—®é¢˜:', {
                    logicalFromDiff,
                    logicalToDiff,
                    spacingDiff
                });
            } else {
                console.log('âœ… [ALIGNMENT] æ—¶é—´è½´å¯¹é½æ­£å¸¸');
            }
        }
        
        // æ£€æŸ¥ 01810 å¯è§æ€§
        function check01810Visibility() {
            if (!mainChart || !mainChart.stockInfos) {
                console.warn('âš ï¸ ä¸»å›¾æˆ–è‚¡ç¥¨ä¿¡æ¯æœªåˆå§‹åŒ–');
                return;
            }
            
            const stock01810Index = mainChart.stockInfos.findIndex(stock => stock.code === 'HK.01810');
            if (stock01810Index === -1) {
                console.warn('âš ï¸ æœªæ‰¾åˆ° HK.01810 è‚¡ç¥¨');
                return;
            }
            
            const stock01810Info = mainChart.stockInfos[stock01810Index];
            const isVisible = mainChart.stockVisibility[stock01810Index] !== false;
            
            console.log('ğŸ” [01810-VIS] HK.01810 å¯è§æ€§çŠ¶æ€:', {
                index: stock01810Index,
                code: stock01810Info.code,
                isVisible: isVisible,
                dataLength: stock01810Info.data?.length,
                firstDate: stock01810Info.data?.[0]?.time,
                lastDate: stock01810Info.data?.[stock01810Info.data.length - 1]?.time
            });
        }
        
        // æ£€æŸ¥ 01810 æ•°æ®èŒƒå›´
        function check01810DataRange(scenario) {
            if (!mainChart || !mainChart.stockInfos) {
                console.warn('âš ï¸ ä¸»å›¾æˆ–è‚¡ç¥¨ä¿¡æ¯æœªåˆå§‹åŒ–');
                return;
            }
            
            const stock01810Index = mainChart.stockInfos.findIndex(stock => stock.code === 'HK.01810');
            if (stock01810Index === -1) {
                console.warn('âš ï¸ æœªæ‰¾åˆ° HK.01810 è‚¡ç¥¨');
                return;
            }
            
            const stock01810Info = mainChart.stockInfos[stock01810Index];
            const currentTimeRange = mainChart.getTimeRange();
            
            console.log(`ğŸ” [01810-RANGE-${scenario}] å½“å‰æ—¶é—´èŒƒå›´:`, currentTimeRange);
            console.log(`ğŸ” [01810-RANGE-${scenario}] 01810 æ•°æ®èŒƒå›´:`, {
                firstDate: stock01810Info.data?.[0]?.time,
                lastDate: stock01810Info.data?.[stock01810Info.data.length - 1]?.time,
                totalDataPoints: stock01810Info.data?.length
            });
            
            // æ£€æŸ¥æ•°æ®æ˜¯å¦è¢«æˆªæ–­
            if (currentTimeRange && stock01810Info.data) {
                const rangeStart = ChartUtils.convertTimeToNumber(currentTimeRange.from);
                const rangeEnd = ChartUtils.convertTimeToNumber(currentTimeRange.to);
                const dataStart = ChartUtils.convertTimeToNumber(stock01810Info.data[0].time);
                const dataEnd = ChartUtils.convertTimeToNumber(stock01810Info.data[stock01810Info.data.length - 1].time);
                
                const isDataTruncated = rangeStart > dataStart || rangeEnd < dataEnd;
                console.log(`ğŸ” [01810-RANGE-${scenario}] æ•°æ®æˆªæ–­æ£€æŸ¥:`, {
                    rangeStart: new Date(rangeStart * 1000).toISOString().split('T')[0],
                    rangeEnd: new Date(rangeEnd * 1000).toISOString().split('T')[0],
                    dataStart: new Date(dataStart * 1000).toISOString().split('T')[0],
                    dataEnd: new Date(dataEnd * 1000).toISOString().split('T')[0],
                    isDataTruncated: isDataTruncated,
                    startTruncated: rangeStart > dataStart,
                    endTruncated: rangeEnd < dataEnd
                });
                
                if (isDataTruncated) {
                    console.warn(`âš ï¸ [01810-RANGE-${scenario}] æ£€æµ‹åˆ° 01810 æ•°æ®æˆªæ–­!`);
                    updateTestResults(`${scenario} - æ•°æ®æˆªæ–­æ£€æŸ¥`, 'warning', 
                        `æ£€æµ‹åˆ°æ•°æ®æˆªæ–­ï¼ŒèŒƒå›´: ${new Date(rangeStart * 1000).toISOString().split('T')[0]} - ${new Date(rangeEnd * 1000).toISOString().split('T')[0]}`);
                } else {
                    console.log(`âœ… [01810-RANGE-${scenario}] 01810 æ•°æ®æ˜¾ç¤ºå®Œæ•´`);
                    updateTestResults(`${scenario} - æ•°æ®æˆªæ–­æ£€æŸ¥`, 'success', 
                        `01810 æ•°æ®å®Œæ•´æ˜¾ç¤ºï¼ŒèŒƒå›´: ${new Date(dataStart * 1000).toISOString().split('T')[0]} - ${new Date(dataEnd * 1000).toISOString().split('T')[0]}`);
                }
            }
        }

        // æ›´æ–°æµ‹è¯•ç»“æœæ˜¾ç¤º
        function updateTestResults(testName, result, details = '') {
            const timestamp = new Date().toLocaleTimeString();
            const resultEntry = {
                timestamp,
                testName,
                result,
                details
            };
            
            testResults.push(resultEntry);
            
            // é™åˆ¶ç»“æœæ•°é‡
            if (testResults.length > 20) {
                testResults = testResults.slice(-15);
            }
            
            const resultsElement = document.getElementById('test-results-content');
            if (resultsElement) {
                const html = testResults.map(entry => {
                    const statusIcon = entry.result === 'success' ? 'âœ…' : 
                                      entry.result === 'warning' ? 'âš ï¸' : 'âŒ';
                    const color = entry.result === 'success' ? '#155724' : 
                                 entry.result === 'warning' ? '#856404' : '#721c24';
                    
                    return `
                        <div style="margin-bottom: 8px; color: ${color};">
                            <strong>[${entry.timestamp}] ${statusIcon} ${entry.testName}</strong>
                            ${entry.details ? `<br><small style="margin-left: 20px;">${entry.details}</small>` : ''}
                        </div>
                    `;
                }).join('');
                
                resultsElement.innerHTML = html;
                resultsElement.scrollTop = resultsElement.scrollHeight;
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåæ˜¾ç¤ºè¯´æ˜
        window.addEventListener('load', () => {
            console.log('ğŸŒŸ LightweightCharts é€»è¾‘èŒƒå›´è°ƒè¯•å·¥å…·å·²åŠ è½½');
            console.log('ğŸ“– ä½¿ç”¨è¯´æ˜:');
            console.log('1. ç‚¹å‡»"å¼€å§‹è°ƒè¯•æµ‹è¯•"åˆ›å»ºå›¾è¡¨å¹¶åŠ è½½æ•°æ®');
            console.log('2. è§‚å¯Ÿè°ƒè¯•æ—¥å¿—ä¸­çš„é€»è¾‘èŒƒå›´å˜åŒ–');
            console.log('3. ç‚¹å‡»"è®°å½•å½“å‰çŠ¶æ€"æŸ¥çœ‹å®æ—¶çŠ¶æ€');
            console.log('4. ç‚¹å‡»"ç›´æ¥æµ‹è¯•ç³»åˆ—åˆ›å»º"è¿›è¡Œç®€åŒ–æµ‹è¯•');
            console.log('ğŸ†• æ–°å¢ HK.01810 ä¸“é¡¹æµ‹è¯•:');
            console.log('5. ç‚¹å‡»"æµ‹è¯• HK.01810 è‚¡ç¥¨æ•°æ®"å•ç‹¬æµ‹è¯•01810è‚¡ç¥¨');
            console.log('6. ç‚¹å‡»"æµ‹è¯•å¤šè‚¡ç¥¨å¯¹é½"æµ‹è¯•å¤šè‚¡ç¥¨æ—¶é—´è½´å¯¹é½');
            console.log('7. ç‚¹å‡»"æµ‹è¯• 01810 ç‰¹å®šé—®é¢˜"é‡ç°æ•°æ®æˆªæ–­é—®é¢˜');
        });
    </script>
</body>
</html> 